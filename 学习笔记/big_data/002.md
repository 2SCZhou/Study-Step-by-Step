### 一个小型数据库的核心组件

#### 一、核心组件

* 映射（Map）

存储数据并提供查询的结构。核心作用是，建立一种key与value的映射关系，当给定某个key的时候，能够返回key对应的value给用户。这是用户进行查询时的主要数据结构。

* 预写式日志（WAL）

队列，记录每次写的操作。当计算机断电时，由于每次写操作都被记录下来了，只要这个日志没有损坏，计算机重启后按照这个log，重放在断电时的写操作，就可以保证你的数据不丢失。

操作思路：记录用户的写入操作(insert,update,delete)->进行内部多次key-value映射的构建，包括主数据，辅助索引数据等->标记该用户操作完成。

* 触发器(trigger)

被动的因为某个事件而触发一段代码逻辑的运行。在数据库内，触发器全部是同步实现的，也就是说，只有当数据写入的操作，以及触发器的操作全部执行完成后，才会返回用户执行成功。

* 锁(lock)

锁的主要目标是允许线程圈定一批资源，并规定该资源只允许发出圈定请求的那个线程进行访问，而其他线程则必须等待。

在数据库的锁实现中，核心问题如下：

1. 尽可能的减少同一时间内被阻塞的线程数，从而提升并行度。
2. 尽可能的避免死锁。

* 执行优化器

这是关系数据库得名的原因，主要的作用是将关系查询转换成key-value查询，输入是sql的抽象语法树（ast），输出则是执行计划（explain sql）。现代数据库实现中，大部分优化器采取基于代价的优化（cbo），之前则多数采取基于规则的优化（rbo）。

* sql解析器

把用户输入的sql转化为计算机可以理解的抽象语法树。

#### 二、外围概念

* 存储过程

存储过程性能好的原因是使用内存代替网络交互。

好处：减少网络交互开销，可以用来封装一些需要高性能的小的业务逻辑单元。

坏处：绑定到特定数据库上，同时，因为大部分存储过程是面向过程的代码，所以运维难度相对较大，不适于处理复杂业务逻辑。


* 视图

视图，从一定程度上利用将不确定性变成确定性的方式，来实现join查询速度的优化和聚焦。

如果不预先告诉数据库哪些表进行join操作，那它可能采取最悲观的方式来对用户的行为进行假定，也就是最坏情况下，所有表都可能产生关联关系，并且关联的次数和频率都是均等的。那么针对这种场景，最安全的策略就是不缓存任何join的中间结果，而只使用通用的join算法进行join计算。

但是，如果用户通过自己的实际业务场景，发现其实有两个表是固定的被join在一起而进行查询的。这种情况就符合了"将不确定性变成确定性"这个优化的前提，因此就可以进行一些优化，**view从某种程度上来说，就是告知数据库这种确定性的一种手段**。

