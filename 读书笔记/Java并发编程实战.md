##第1章
####1、为什么需要并发？
资源利用率，公平性，便利性。
####2、冯.诺依曼计算机
####3、何为线程，线程带来的风险？
* 安全性问题：竞态条件，线程同步
* 活跃性问题：正确的事情最终会发生。死锁，饥饿，活锁。
* 性能问题：正确的事情尽早发生。服务时间，响应速度，吞吐率，资源消耗，可伸缩。

##第2章 线程安全性
####1、编写线程安全的代码的核心？
对状态访问操作进行管理，特别是对共享(Shared)的和可变(Mutable)的状态的访问。
####2、编写并发应用程序的一种正确的编程方法：
首先使代码正确运行，然后再提高代码的速度。即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实带来性能提升时，才进行优化。
####3、什么是线程安全性？
在线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。  

定义：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。  

####4、无状态？
无状态：即不包含任何域，也不包含任何对其他类中域的引用。  

无状态对象一定是线程安全的。
####5、竞态条件
竞态条件：由于不恰当的执行时序而出现不正确的结果。  

最常见的竞态条件类型：先检查后执行(Check-Then-Act)，通过可能失效的观测结果来执行下一步的动作，常见的情况比如延迟初始化。
####6、数据竞争
数据竞争：如果在访问共享的非final类型的域时，没有采用同步来进行协同，那么就会出现数据竞争。

并非所有的竞态条件都是数据竞争，也并不是所有的数据竞争都是竞态条件。
####7、原子操作
原子操作：对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个以原子方式执行的操作。

复合操作：包含了一组必须以原子方式执行的操作，以确保线程安全性，比如“先检测后执行”，“读取-修改-写入”。

原子：一组语句作为一个不可分割的单元被执行。
####8、Java锁机制
同步代码块，内置锁，监视器锁，互斥锁。
####9、重入
内置锁是可重入的，“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。

**why？what？how？对每个概念多要有这3问！**
####10、活跃性与性能
不良并发应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。
安全性，简单性，性能的权衡，当执行时间较长的计算或可能无法快速完成的操作时，一定不要持有锁。

##第3章 对象的共享
####1、可见性，重排序
为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
####2、最低安全性，非原子的64位操作
最低安全性：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证被称为最低安全性。

最低安全性适用于绝大多数变量，但存在一个例外：非volatile类型的64位数值变量（double和long）。
64 = 32高 + 32低。锁或volatile。
####3、加锁与可见性
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。
####4、volatile变量
volatile变量，用来将变量的更新操作通知到其他线程。当变量声明为volatile类型后，编译器与运行时会注意这个变量是共享的，也就不会将对它的操作进行重排序，也不会将它缓存到寄存器或其他处理器不可见的地方，因此读取volatile类型的变量时总会返回最新写入的值。

volatile变量，不加锁，不阻塞线程，比synchronized关键字更轻量级的同步机制。脆弱，难理解。

适用场合：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生(例如，初始化或关闭)。如果在验证正确性时，需要对可见性进行复杂的判断，那就不要使用volatile变量。

JVM -server参数，JVM会进行优化。JVM的server模式和client模式。

加锁机制即可确保可见性又可确保原子性，而volatile变量只能确保可见性。
####5、发布与逸出
* 发布publish：使一个对象能够在当前作用域之外的代码中使用。
* 逸出escape：当某个不应该发布的对象被发布时，这种情况就被称为逸出。

####6、线程封闭
线程封闭：将对对象(数据)的访问封闭到单个线程中，这样不需要同步，是实现线程安全性的最简单方式之一。

线程封闭技术常见应用：Swing，JDBC。
####7、线程封闭技术
* Ad-hoc线程封闭：维护线程封闭的职责完全由程序实现来承担，脆弱。
* 栈封闭：Java基本类型局部变量始终封闭在线程内，对于对象引用的栈封闭，需要确保被引用的对象不会逸出。
* ThreadLocal对象通常用于防止对可变的单实例变量(Singleton)或全局变量进行共享，例如JDBC连接。缺点？

####8、不变性
不可变对象：如果某个对象在被创建后其状态就不能修改，则这个对象就称为不可变对象。不可变对象一定是线程安全的。

不可变对象的条件：对象创建以后其状态就不能修改。对象的所有域都是final类型。对象是正确创建的（在对象的创建期间，this引用没有逸出）。
####9、final域
final类型的域是不能修改的，在Java内存模型中，final域还有特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些变量时无须同步。

两条很好的编程习惯：
* 除非需要更高的可见性，否则应将所有的域都声明为私有域；
* 除非需要某个域是可变的，否则应将其声明为final域。

在某些情况下，不可变对象能提供一种弱形式的原子性，这样可以结合volatile类型的可见性和final类型的原子性来实现轻量级的线程安全。
####10、安全发布的常用模式
要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方法来安全地发布：
* 在静态初始化函数中初始化一个对象引用。
* 将对象的引用保存在volatile类型的域或者AtomicReference对象中。
* 将对象的引用保存在某个正确构造对象的final类型域中。
* 将对象的引用保存在一个由锁保护的域中。
* 对象的发布需求取决于它的可变性：
* 不可变对象可以通过任意机制来发布。
* 事实不可变对象必须通过安全方式来发布。
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

并发程序中使用和共享对象时，一些实用策略：
* 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
* 只读共享。在没有额外同步的情况下，共享的只读变量可以由多个线程并发访问，但任何线程都不能修改它。共享的只读变量包括不可变对象和事实不可变对象。
* 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
* 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

##第4章 对象的组合
####1、设计线程安全类的3个基本要素：
* 找出构成对象状态的所有变量。
* 找出约束状态变量的不变性条件。
* 建立对象状态的并发访问管理策略。

要满足状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。
####2、实例封闭
将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

封闭机制更容易构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就不需检查整个程序。

Java监视器模式：遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。
####3、线程安全性的委托
委托给单个线程安全的状态变量；委托给多个彼此独立的状态变量；
####4、在现有的线程安全类中添加功能
修改原始的类；扩展现有的类；客户端加锁（注意要使用正确的锁！）。
何为内置锁？？？

##第5章 基础构建模块
####1、同步容器类
同步容器类：Vector，Hashtable及同步的封装器类Collections.synchronizedXxx工厂方法创建的类。这些类实现线程安全的方式：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

同步容器类：确保了线程安全性，却牺牲了并发性。
####2、并发容器
ConcurrentHashMap，CopyOnWriteArrayList，Queue，BlockingQueue，ConcurrentLinkedQueue，PriorityQueue，ConcurrentSkipListMap，ConcurrentSkipListSet等并发容器，详见Java并发包。
* ConcurrentHashMap：用于替代同步且基于散列的Map。优点：分段锁，在并发访问环境下实现更高的吞吐量，在单线程环境中只损失非常小的性能。缺点：不支持客户端加锁，无法创建新的原子操作。
* CopyOnWriteArrayList：用于替代同步List，某些情况下提供更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。

优点：写入时复制，线程安全性在于只要正确地发布一个事实不可变对象，那在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

缺点：修改容器时需要复制底层数组，有一定的开销。仅当迭代操作远远多于修改操作时使用，比如事件通知系统。
####3、队列
* 阻塞队列：生产者消费者模式，线程池，工作队列，串行线程封闭。
* 双端队列：Deque，BlockingDeque，工作密取。

####4、阻塞方法和中断方法
阻塞和中断这个需要好好理解！！！InterruptedException，Thread.currentThread().interrupt()。中断是一种协作机制！
####5、同步工具类
* 闭锁：一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁就像一扇门，可以用来确保某些活动直到其他活动都完成后才能继续执行。二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。
CountDownLatch是一种灵活的闭锁实现。如何实现的？？？？
* FutureTask：也可以用作闭锁，实现了Future语义，表示一种抽象的可生成结果的计算。
* 信号量：计数信号量用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。Semaphore，permit许可，二值信号量，互斥体mutex，不可重入。
* 栅栏：闭锁可以用来启动一组相关的操作，或者等待一组相关的操作结果，但闭锁是一次性对象，一旦进入终止状态，就不能被重置。栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。CyclicBarrier可以是一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用。n-body粒子模拟系统，Conwy生命游戏。Exchanger是另一种形式的栅栏，两方栅栏，各方在栅栏位置上交换数据。

**动手实践题：如何构建高效且可伸缩的结果缓存？？？**

##第6章 任务执行
####1、在线程中执行任务
任务边界，负荷过载，逐渐失败，直接失败，清晰的任务边界+明确的任务执行策略。

大多数服务器应用提供了一种自然的任务边界选择方法：以独立的客户请求作为边界。既可以实现任务的独立性，又可以实现合理的任务规模。Web服务器，邮件服务器，文件服务器，EJB容器，数据库服务器等。
####2、Executor框架
Executor框架，将请求处理任务的提交与·任务的实际执行解耦出来，并且只需要采用另一种不同的Executor实现就可以改变服务器的行为。

执行策略：What，Where，When，How。

线程池：管理一组同构工作线程的资源池，常用的有，newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool等。

Executor可以实现各种调优，管理，监视，记录日志，错误报告和其他功能。

Executor的生命周期：为了解决执行服务的生命周期，Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法。
* shutdown方法执行平缓关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成-包括那些还未执行的任务。
* shutdownNow方法执行粗暴关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。

####3、延迟任务与周期任务
Timer的缺陷：Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时准确性。

Timer的另一个问题是，如果TimerTask抛出一个未检查的异常，那么Timer线程将不捕获异常，因此当TimerTask抛出未检查的异常时将终止定时线程，导致已经被调度当尚未执行的TimerTask将不会执行，新的任务也不能调度，这就是线程泄露！
Timer支持基于绝对时间而不是相对时间的调度机制，因此任务的执行对系统时钟变化很敏感，而ScheduledThreadPoolExecutor只支持基于相对时间的调度。

##第7章 取消与关闭
####1、任务取消
在Java中没有一种安全的抢占式方法来停止线程，因此也就没有一种安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。
* 方法1：volatile类型的“已请求取消”状态标识。
* 方法2：中断。状态标识检查对于调用阻塞方法的任务是不合适的，所以需要通过中断来取消任务。

####2、线程中断
线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。

每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true。Thread类中，interrupt方法能中断目标线程（设置中断状态）。isInterrupted方法能返回目标线程的中断状态。静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这是清除中断状态的唯一方法。

阻塞库方法，如Thread.sleep和Object.wait，join等，都会检查线程何时中断，并且发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出InterruptedException，表示阻塞操作由于中断而提前结束。

当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。这样，如果不触发InterruptException，那么中断状态将一直保持，直到明确地清除中断状态。

如何正确理解中断？中断并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。
在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理—可以抛出InterruptedException，或通过再次调用interrupt来恢复中断状态。
通常，中断是实现取消的最合理方式。
####3、中断策略

中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多快的速度来相应中断。

最合理的中断策略：提供某种形式的线程级（Thread-Level）取消操作或服务级（Service-Level）取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准中断策略的线程或线程池，只能用于能知道这些策略的任务中。

大多数可阻塞的库函数为什么只抛出InterruptException作为中断响应：它们永远不会在某个由自己拥有的线程中运行，因此它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈的上层代码采取进一步的操作。

当检查到中断请求时，任务不需要放弃所有的操作——它可以推迟处理中断请求，并且到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出InterruptException或者表示已收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。
####４、停止基于线程的服务
应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。

正确的封装原则：除非拥有某个线程，否则不能对该线程进行操作，比如中断线程或修改线程的优先级。
线程的所有权：线程API中并没有对线程所有权给出正式的定义，线程由Thread对象表示，并且像其他对象一样可以被自由共享。然而，线程有一个相应的所有者，即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那应该使用线程池。

与其他封装对象一样，线程的所有权是不可传递的，应用程序可以拥有服务（线程池等），服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应该提供生命周期方法（Lifecycle Method）来关闭它自己以及它所拥有的线程。这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。ExecutorService中提供了shutdown和shutdownNow等方法。同样，其他拥有线程的服务中也应该提供类似的关闭机制。
对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。

**实践：实现一个日志服务！！！**

##第8章 线程池的使用

to be continue.....
